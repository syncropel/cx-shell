# /.github/workflows/release.yaml

name: Build and Release CX Shell

on:
  push:
    tags:
      - "v*" # Trigger on any tag like v0.1.0

jobs:
  test:
    name: Run Unit & Integration Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install uv
        run: pip install uv

      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/uv
          key: ${{ runner.os }}-uv-${{ hashFiles('**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-uv-

      - name: Install dependencies including test tools
        run: |
          uv venv
          uv pip install -e .[all]

      - name: Run Pytest
        run: |
          source .venv/bin/activate
          python -m pytest

  build-linux:
    name: Build Standalone Linux Executable
    needs: test
    runs-on: ubuntu-latest
    timeout-minutes: 25

    # This container block is the key to glibc portability.
    # It forces the build to happen in an older, stable Linux environment.
    container:
      image: python:3.12-slim-bullseye

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install build tools inside container
        run: |
          apt-get update
          apt-get install -y --no-install-recommends patchelf upx git
          pip install pyinstaller uv

      - name: Install ONLY CORE application dependencies
        run: |
          uv venv .pyinstaller-venv
          source .pyinstaller-venv/bin/activate
          # We explicitly install only the core package, not '[all]' extras.
          # This is the key to creating a smaller binary by excluding
          # heavy optional dependencies like pandas, sqlalchemy, etc.
          uv pip install -e .

      - name: Build the executable with PyInstaller
        run: |
          source .pyinstaller-venv/bin/activate
          # Use the .spec file for fine-grained control over the build process.
          pyinstaller cx.spec --noconfirm

      - name: Verify build artifacts and check size
        run: |
          echo "--- Verifying binary was created in dist/ ---"
          ls -lh dist/
          # This acts as a safeguard against accidentally including heavy packages.
          find dist/cx -type f -size +60M -exec echo "::error::Binary size exceeds 60MB limit!" \; -exec exit 1 \;
          echo "--- Binary size is within acceptable limits. ---"

      - name: Smoke Test the PyInstaller Binary
        run: |
          echo "--- Running smoke test on built binary ---"
          # Create a clean, isolated home directory to simulate a new user's machine.
          export HOME=/tmp/test-home
          mkdir -p $HOME

          echo "--- 1. Testing '--version' command ---"
          ./dist/cx --version

          echo "--- 2. Testing 'init' command ---"
          # The `init` command is the most critical first-run test, as it verifies
          # that bundled assets were correctly included by PyInstaller.
          ./dist/cx init

          echo "--- Verifying that 'init' created files ---"
          # Check that the command created the expected directory and a sample file.
          ls -l $HOME/.cx/connections/
          if [ ! -f "$HOME/.cx/connections/github.conn.yaml" ]; then
            echo "::error::'cx init' failed to create sample connection file!"
            exit 1
          fi

          echo "--- ✅ Binary smoke test PASSED ---"

      - name: Prepare and Archive Linux Executable
        id: prepare_artifact
        shell: bash
        run: |
          VERSION=${{ github.ref_name }}
          ARCHIVE_NAME="cx-${VERSION}-linux-x86_64.tar.gz"

          # Create the final distributable archive.
          tar -czvf "${ARCHIVE_NAME}" -C dist cx

          # Set environment variables for use in subsequent steps.
          echo "ASSET_PATH=${ARCHIVE_NAME}" >> $GITHUB_ENV
          echo "ASSET_NAME=${ARCHIVE_NAME}" >> $GITHUB_ENV

      - name: Smoke Test the Final Archive
        run: |
          echo "--- Verifying final artifact: ${{ env.ASSET_NAME }} ---"
          mkdir -p /tmp/test-install
          tar -xzf ${{ env.ASSET_NAME }} -C /tmp/test-install

          echo "--- Running smoke test on extracted artifact ---"
          /tmp/test-install/cx --version
          echo "--- ✅ Final artifact smoke test PASSED ---"

      - name: Upload Linux artifact for release job
        uses: actions/upload-artifact@v4
        with:
          name: linux-artifact
          path: ${{ env.ASSET_PATH }}

  # Placeholder for future macOS and Windows build jobs.
  # build-macos:
  #   ...
  # build-windows:
  #   ...

  release:
    name: Create GitHub Release
    # This job will depend on all build jobs in the future (e.g., [build-linux, build-macos]).
    needs: [build-linux]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Download all built artifacts from previous jobs
        uses: actions/download-artifact@v4
        with:
          path: release-assets

      - name: List downloaded artifacts for verification
        run: ls -R release-assets

      - name: Create release and upload all assets
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          # This will upload all files found in the release-assets directory and its subdirectories.
          files: release-assets/**/*
